<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Earth Globe</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      overflow: hidden;
      background: #0a2e1a;
    }
    
    canvas {
      display: block;
    }
    
    .info {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: rgba(0, 100, 50, 0.6);
      padding: 12px 24px;
      border-radius: 30px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="info">ğŸŒ CCUS around the world</div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r169/three.min.js"></script>
  <script>
    // Scene, Camera, Renderer ì„¤ì •
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 3;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x0a2e1a);
    document.body.appendChild(renderer.domElement);

    // ë°°ê²½ íŒŒí‹°í´ (ìš°ì£¼ ë¨¼ì§€/ë³„) ìƒì„±
    function createBackgroundParticles() {
      const particleCount = 3000;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);

      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        
        // ë„“ì€ ë²”ìœ„ì— ëœë¤ ë°°ì¹˜
        positions[i3] = (Math.random() - 0.5) * 20;
        positions[i3 + 1] = (Math.random() - 0.5) * 20;
        positions[i3 + 2] = (Math.random() - 0.5) * 20;

        // ë…¹ìƒ‰ ê³„ì—´ ìƒ‰ìƒ ë³€í™”
        const greenIntensity = 0.3 + Math.random() * 0.7;
        colors[i3] = 0.1 + Math.random() * 0.2;      // R
        colors[i3 + 1] = greenIntensity;              // G
        colors[i3 + 2] = 0.1 + Math.random() * 0.3;  // B

        sizes[i] = Math.random() * 3 + 1;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      const material = new THREE.PointsMaterial({
        size: 0.03,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending
      });

      return new THREE.Points(geometry, material);
    }

    // ì§€êµ¬ ë°ì´í„° (ê°„ë‹¨í•œ ëŒ€ë¥™ ì¢Œí‘œ - ìœ„ë„/ê²½ë„ ê¸°ë°˜)
    const continentData = [
      // ë¶ë¯¸
      ...generateContinentPoints(-130, -60, 25, 70, 800),
      // ë‚¨ë¯¸
      ...generateContinentPoints(-80, -35, -55, 12, 500),
      // ìœ ëŸ½
      ...generateContinentPoints(-10, 40, 35, 70, 400),
      // ì•„í”„ë¦¬ì¹´
      ...generateContinentPoints(-20, 50, -35, 35, 600),
      // ì•„ì‹œì•„
      ...generateContinentPoints(40, 150, 5, 75, 1200),
      // í˜¸ì£¼
      ...generateContinentPoints(110, 155, -45, -10, 300),
    ];

    function generateContinentPoints(lonMin, lonMax, latMin, latMax, count) {
      const points = [];
      for (let i = 0; i < count; i++) {
        const lon = lonMin + Math.random() * (lonMax - lonMin);
        const lat = latMin + Math.random() * (latMax - latMin);
        points.push({ lon, lat });
      }
      return points;
    }

    // ìœ„ë„/ê²½ë„ë¥¼ 3D ì¢Œí‘œë¡œ ë³€í™˜
    function latLonToVector3(lat, lon, radius) {
      const phi = (90 - lat) * (Math.PI / 180);
      const theta = (lon + 180) * (Math.PI / 180);

      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.cos(phi);
      const z = radius * Math.sin(phi) * Math.sin(theta);

      return new THREE.Vector3(x, y, z);
    }

    // íŒŒí‹°í´ ì§€êµ¬ë³¸ ìƒì„±
    function createParticleEarth() {
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];

      const earthRadius = 1;

      // ëŒ€ë¥™ íŒŒí‹°í´
      continentData.forEach(point => {
        const pos = latLonToVector3(point.lat, point.lon, earthRadius);
        // ì•½ê°„ì˜ ëœë¤ ì˜¤í”„ì…‹ ì¶”ê°€
        pos.x += (Math.random() - 0.5) * 0.02;
        pos.y += (Math.random() - 0.5) * 0.02;
        pos.z += (Math.random() - 0.5) * 0.02;
        
        positions.push(pos.x, pos.y, pos.z);
        
        // í°ìƒ‰ ê³„ì—´
        const brightness = 0.8 + Math.random() * 0.2;
        colors.push(brightness, brightness, brightness);
      });

      // ì¶”ê°€ ê¸€ë¡œìš° íŒŒí‹°í´ (ì§€êµ¬ ì£¼ë³€)
      for (let i = 0; i < 500; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const radius = earthRadius + 0.02 + Math.random() * 0.05;

        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.sin(phi) * Math.sin(theta);
        const z = radius * Math.cos(phi);

        positions.push(x, y, z);
        
        // ì—°í•œ ë…¹ìƒ‰/ì²­ë¡ìƒ‰ ê¸€ë¡œìš°
        colors.push(0.5 + Math.random() * 0.3, 0.9, 0.7 + Math.random() * 0.3);
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));

      const material = new THREE.PointsMaterial({
        size: 0.015,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending
      });

      return new THREE.Points(geometry, material);
    }

    // ì§€êµ¬ í…Œë‘ë¦¬ (ì™€ì´ì–´í”„ë ˆì„ ëŠë‚Œ)
    function createEarthOutline() {
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];
      
      // ìœ„ë„ì„ 
      for (let lat = -60; lat <= 60; lat += 30) {
        for (let lon = 0; lon < 360; lon += 2) {
          const pos = latLonToVector3(lat, lon, 1.01);
          positions.push(pos.x, pos.y, pos.z);
          colors.push(0.2, 0.5, 0.3);
        }
      }
      
      // ê²½ë„ì„ 
      for (let lon = 0; lon < 360; lon += 30) {
        for (let lat = -90; lat <= 90; lat += 2) {
          const pos = latLonToVector3(lat, lon, 1.01);
          positions.push(pos.x, pos.y, pos.z);
          colors.push(0.2, 0.5, 0.3);
        }
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));

      const material = new THREE.PointsMaterial({
        size: 0.008,
        vertexColors: true,
        transparent: true,
        opacity: 0.3,
        sizeAttenuation: true
      });

      return new THREE.Points(geometry, material);
    }

    // ì”¬ì— ì˜¤ë¸Œì íŠ¸ ì¶”ê°€
    const backgroundParticles = createBackgroundParticles();
    const particleEarth = createParticleEarth();
    const earthOutline = createEarthOutline();

    scene.add(backgroundParticles);
    scene.add(particleEarth);
    scene.add(earthOutline);

    // ë§ˆìš°ìŠ¤ ì¸í„°ë™ì…˜
    let mouseX = 0;
    let mouseY = 0;
    let targetRotationX = 0;
    let targetRotationY = 0;

    document.addEventListener('mousemove', (event) => {
      mouseX = (event.clientX / window.innerWidth) * 2 - 1;
      mouseY = (event.clientY / window.innerHeight) * 2 - 1;
    });

    // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
    function animate() {
      requestAnimationFrame(animate);

      // ì§€êµ¬ ìë™ íšŒì „
      particleEarth.rotation.y += 0.002;
      earthOutline.rotation.y += 0.002;

      // ë§ˆìš°ìŠ¤ ê¸°ë°˜ ì¶”ê°€ íšŒì „
      targetRotationX = mouseY * 0.3;
      targetRotationY = mouseX * 0.3;

      particleEarth.rotation.x += (targetRotationX - particleEarth.rotation.x) * 0.05;
      earthOutline.rotation.x = particleEarth.rotation.x;

      // ë°°ê²½ íŒŒí‹°í´ ì²œì²œíˆ íšŒì „
      backgroundParticles.rotation.y += 0.0003;
      backgroundParticles.rotation.x += 0.0001;

      // ë°°ê²½ íŒŒí‹°í´ ë¯¸ì„¸í•œ ì›€ì§ì„
      const positions = backgroundParticles.geometry.attributes.position.array;
      const time = Date.now() * 0.0001;
      
      for (let i = 0; i < positions.length; i += 3) {
        positions[i + 1] += Math.sin(time + i) * 0.0005;
      }
      backgroundParticles.geometry.attributes.position.needsUpdate = true;

      renderer.render(scene, camera);
    }

    // ì°½ í¬ê¸° ì¡°ì ˆ ëŒ€ì‘
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>